# Отчет по работе над системой ISIT
## Информационная система учета операционных расходов

---

## 1. Инструкция по инсталляции и запуску разработанного программного обеспечения

### 1.1. Системные требования

**Минимальные требования:**
- Операционная система: Linux (Ubuntu 20.04+), macOS, или Windows с WSL2
- Docker версии 20.10 или выше
- Docker Compose версии 1.29 или выше
- 4 ГБ свободной оперативной памяти
- 10 ГБ свободного места на диске

**Для локальной разработки (без Docker):**
- Rust (stable) версии 1.70 или выше
- Node.js версии 18 или выше
- PostgreSQL версии 16 или выше

### 1.2. Установка через Docker Compose (рекомендуемый способ)

#### Шаг 1: Клонирование репозитория

```bash
git clone https://github.com/kemuri-ni-deteitta/ISIT.git
cd ISIT
```

#### Шаг 2: Запуск всех сервисов

```bash
docker compose up --build
```

Эта команда автоматически:
- Создаст и запустит контейнер PostgreSQL с базой данных
- Создаст и запустит контейнер MinIO для хранения файлов
- Создаст и запустит контейнер MailHog для тестирования email
- Соберет и запустит backend (Rust/Axum)
- Соберет и запустит frontend (Next.js)

#### Шаг 3: Проверка работоспособности

После запуска проверьте доступность сервисов:

- **Frontend:** http://localhost:3000 (или http://localhost:5173 при использовании Docker)
- **Backend API:** http://localhost:8080/healthz
- **PostgreSQL:** localhost:5432
- **MinIO Console:** http://localhost:9001
- **MailHog UI:** http://localhost:8025

### 1.3. Установка для локальной разработки

#### Запуск PostgreSQL через Docker

```bash
cd /home/ivan/ISIT
sudo docker compose up -d postgres
```

Подождите 10-15 секунд для инициализации базы данных.

#### Настройка и запуск Backend

```bash
cd backend

# Создание файла .env
cat > .env << EOF
DATABASE_URL=postgres://isit:isit@localhost:5432/isit
SERVER_PORT=8080
ALLOWED_ORIGINS=http://localhost:3000
RUST_LOG=info
EOF

# Запуск backend
cargo run
```

Backend будет доступен по адресу: http://localhost:8080

#### Настройка и запуск Frontend

```bash
cd frontend

# Создание файла .env.local
echo "NEXT_PUBLIC_API_BASE_URL=http://localhost:8080" > .env.local

# Установка зависимостей (если еще не установлены)
npm install

# Запуск frontend
npm run dev
```

Frontend будет доступен по адресу: http://localhost:3000

### 1.4. Пароли и учетные данные доступа

#### База данных PostgreSQL

- **Хост:** localhost
- **Порт:** 5432
- **База данных:** isit
- **Пользователь:** isit
- **Пароль:** isit

**Подключение через psql:**
```bash
sudo docker exec -it isit_postgres psql -U isit -d isit
```

Или с хоста:
```bash
PGPASSWORD=isit psql -h localhost -p 5432 -U isit -d isit
```

#### MinIO Object Storage

- **Console URL:** http://localhost:9001
- **API Endpoint:** http://localhost:9000
- **Root User:** admin
- **Root Password:** adminadmin
- **Bucket:** isit-attachments (создается автоматически)

#### Системный пользователь по умолчанию

- **Email:** admin@isit.local
- **ID:** 00000000-0000-0000-0000-000000000001
- **Имя:** System Administrator
- **Статус:** active

**Примечание:** В текущей версии система использует placeholder для хеша пароля. В production необходимо реализовать полноценную аутентификацию с использованием Argon2.

#### MailHog (тестирование email)

- **Web UI:** http://localhost:8025
- **SMTP Server:** localhost:1025
- Пароль не требуется (только для локальной разработки)

### 1.5. Миграции базы данных

Миграции выполняются автоматически при запуске backend. Все файлы миграций находятся в директории `backend/migrations/`:

- `20250101000000_initial_schema.sql` - начальная схема БД
- `20250101000001_seed_data.sql` - начальные справочные данные
- `20250101000002_seed_default_user.sql` - пользователь по умолчанию
- `20250101000003_translate_to_russian.sql` - перевод на русский язык
- `20250113000000_add_expense_fields.sql` - дополнительные поля расходов
- `20250113010000_add_funding_sources.sql` - источники финансирования
- `20250113020000_remove_funding_source_check.sql` - удаление ограничений
- `20251113030000_seed_sample_expenses_for_analytics.sql` - тестовые данные для аналитики

### 1.6. Остановка сервисов

**Остановка всех контейнеров:**
```bash
docker compose down
```

**Остановка с удалением volumes (удалит все данные):**
```bash
docker compose down -v
```

---

## 2. Основные алгоритмы и математические модели обработки данных

### 2.1. Алгоритм агрегации расходов по категориям

Система использует алгоритм группировки и суммирования расходов для построения аналитических отчетов.

#### Математическая модель

Для множества расходов \( E = \{e_1, e_2, ..., e_n\} \), где каждый расход \( e_i \) характеризуется:
- \( c_i \) - идентификатор категории
- \( a_i \) - сумма расхода (decimal)
- \( d_i \) - дата расхода

Агрегированная сумма по категории \( c \) вычисляется как:

\[
S(c) = \sum_{i: c_i = c} a_i
\]

#### Реализация алгоритма

**Frontend (TypeScript):**
```typescript
const sumsByCategoryId: Record<string, number> = {};
for (const e of filteredExpenses) {
  const key = e.category_id;
  const amount = Number(e.amount || "0");
  sumsByCategoryId[key] = (sumsByCategoryId[key] || 0) + amount;
}
```

**Временная сложность:** O(n), где n - количество расходов
**Пространственная сложность:** O(k), где k - количество уникальных категорий

### 2.2. Алгоритм фильтрации по временным периодам

Система поддерживает фильтрацию расходов по следующим периодам:
- Последние 7 дней
- Последние 30 дней
- Текущий месяц
- Все время

#### Математическая модель

Для периода \( P \) и текущей даты \( T \), множество отфильтрованных расходов:

\[
E_P = \{e_i \in E : d_i \geq T_P\}
\]

где \( T_P \) - начальная дата периода:
- \( T_{7days} = T - 7 \) дней
- \( T_{30days} = T - 30 \) дней
- \( T_{month} = \) первый день текущего месяца
- \( T_{all} = -\infty \) (все расходы)

#### Реализация

```typescript
function getDateFromPeriod(p: PeriodOption): Date | null {
  const now = new Date();
  switch (p) {
    case "last_7_days":
      return new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
    case "last_30_days":
      return new Date(now.getFullYear(), now.getMonth(), now.getDate() - 30);
    case "this_month":
      return new Date(now.getFullYear(), now.getMonth(), 1);
    case "all":
    default:
      return null;
  }
}

const filteredExpenses = expenses.filter((e) => {
  const from = getDateFromPeriod(period);
  if (!from) return true;
  return new Date(e.incurred_on) >= from;
});
```

### 2.3. Алгоритм пагинации данных

Система использует offset-based пагинацию для эффективной загрузки больших объемов данных.

#### Математическая модель

Для страницы \( p \) и размера страницы \( s \):

\[
offset = (p - 1) \times s
\]

\[
E_{page} = \{e_i \in E : offset \leq i < offset + s\}
\]

#### Реализация (Backend, Rust)

```rust
let offset = (page.saturating_sub(1)) * page_size;

let rows = sqlx::query(
    "SELECT * FROM expenses 
     ORDER BY incurred_on DESC, created_at DESC 
     LIMIT $1 OFFSET $2"
)
.bind(page_size as i64)
.bind(offset as i64)
.fetch_all(pool)
.await?;
```

**Временная сложность:** O(n log n) для сортировки + O(s) для выборки, где s - размер страницы

### 2.4. Алгоритм сортировки данных

Система сортирует расходы по двум критериям:
1. По дате расхода (incurred_on) - по убыванию
2. По дате создания (created_at) - по убыванию (вторичный критерий)

#### Математическая модель

Множество расходов сортируется по отношению порядка:

\[
e_i \prec e_j \Leftrightarrow (d_i > d_j) \lor ((d_i = d_j) \land (t_i > t_j))
\]

где:
- \( d_i \) - дата расхода \( e_i \)
- \( t_i \) - время создания \( e_i \)

#### Реализация

```sql
ORDER BY incurred_on DESC, created_at DESC
```

**Временная сложность:** O(n log n) - стандартная сложность сортировки в PostgreSQL

### 2.5. Модель данных для финансовых расчетов

Система использует тип `DECIMAL(15, 2)` для хранения денежных сумм, что обеспечивает:
- Точность до 2 знаков после запятой
- Диапазон значений: от -999,999,999,999,999.99 до 999,999,999,999,999.99
- Отсутствие ошибок округления при арифметических операциях

#### Преобразование типов

**Backend (Rust):**
```rust
use rust_decimal::Decimal;

// Преобразование из строки в Decimal
let amount = Decimal::from_str_exact(amount_str)
    .unwrap_or_default();

// Преобразование Decimal в строку для SQL
let amount_str = req.amount.to_string();
```

**Frontend (TypeScript):**
```typescript
// Преобразование строки в число для расчетов
const amount = Number(e.amount || "0");
```

### 2.6. Алгоритм построения графиков

Система поддерживает три типа визуализации:
1. Круговая диаграмма (Pie Chart)
2. Столбчатая диаграмма (Bar Chart)
3. Линейный график (Line Chart)

#### Модель данных для графиков

Для каждой категории \( c \) с суммой \( S(c) \) создается точка данных:

\[
D(c) = \{name: N(c), value: S(c)\}
\]

где \( N(c) \) - название категории.

Данные сортируются по убыванию значения:

\[
D_{sorted} = sort(D, key = value, order = descending)
\]

#### Реализация

```typescript
const entries = categoryIds.map((categoryId) => ({
  name: categoryNameById[categoryId] || categoryId,
  value: sumsByCategoryId[categoryId] || 0,
}));

// Сортировка по убыванию значения
return entries.sort((a, b) => b.value - a.value);
```

### 2.7. Алгоритм валидации данных

#### Валидация суммы расхода

\[
a > 0
\]

где \( a \) - сумма расхода.

#### Валидация статуса

Статус должен принадлежать множеству допустимых значений:

\[
status \in \{pending, approved, rejected, paid\}
\]

#### Валидация даты

Дата расхода не может быть в будущем относительно текущей даты:

\[
d \leq T_{today}
\]

### 2.8. Индексация базы данных для оптимизации запросов

Система использует следующие индексы для ускорения запросов:

1. **Индекс по категории и дате:**
   ```sql
   CREATE INDEX idx_expenses_category_date 
   ON expenses(category_id, incurred_on);
   ```

2. **Индекс по отделу и дате:**
   ```sql
   CREATE INDEX idx_expenses_department_date 
   ON expenses(department_id, incurred_on);
   ```

3. **Индекс по статусу:**
   ```sql
   CREATE INDEX idx_expenses_status 
   ON expenses(status);
   ```

**Временная сложность поиска:** O(log n) вместо O(n) для полного сканирования таблицы

---

## 3. Дополнительная информация для проверки программного обеспечения

### 3.1. Архитектура системы

Система построена по принципу клиент-серверной архитектуры с разделением на три основных компонента:

#### Backend (Rust/Axum)
- **Язык:** Rust
- **Фреймворк:** Axum (асинхронный веб-фреймворк)
- **База данных:** PostgreSQL 16
- **ORM:** SQLx (compile-time проверка SQL запросов)
- **Порт:** 8080

**Основные модули:**
- `domain/` - доменные модели (Expense, User, Category, Department, FundingSource)
- `repositories/` - слой доступа к данным
- `http/` - HTTP handlers для REST API
- `db/` - подключение к БД и миграции

#### Frontend (Next.js/React)
- **Язык:** TypeScript
- **Фреймворк:** Next.js 16 (App Router)
- **UI библиотека:** Chakra UI v3
- **State Management:** Redux Toolkit
- **Графики:** Recharts
- **Порт:** 3000 (в разработке) или 5173 (в Docker)

**Основные страницы:**
- `/` - Главная страница
- `/expenses` - Учет затрат
- `/analytics` - Аналитика и отчетность
- `/admin-panel` - Управление пользователями
- `/departments` - Управление отделами
- `/funding-sources` - Управление источниками финансирования
- `/type_of_expenditure` - Типы расходов

#### База данных (PostgreSQL)
- **Версия:** PostgreSQL 16
- **Схема:** Нормализованная реляционная модель
- **Миграции:** Автоматическое выполнение при старте backend

### 3.2. API Endpoints

#### Expenses (Расходы)
- `GET /api/v1/expenses` - Список расходов с пагинацией
- `GET /api/v1/expenses/:id` - Получить расход по ID
- `POST /api/v1/expenses` - Создать новый расход
- `PUT /api/v1/expenses/:id` - Обновить расход
- `DELETE /api/v1/expenses/:id` - Удалить расход

**Query параметры для GET /api/v1/expenses:**
- `page` (default: 1) - номер страницы
- `page_size` (default: 20) - размер страницы
- `department_id` (optional) - фильтр по отделу
- `category_id` (optional) - фильтр по категории
- `status` (optional) - фильтр по статусу
- `date_from` (optional) - начальная дата
- `date_to` (optional) - конечная дата

#### Departments (Отделы)
- `GET /api/v1/departments` - Список отделов
- `POST /api/v1/departments` - Создать отдел
- `PUT /api/v1/departments/:id` - Обновить отдел
- `DELETE /api/v1/departments/:id` - Удалить отдел

#### Categories (Категории)
- `GET /api/v1/categories` - Список категорий
- `POST /api/v1/categories` - Создать категорию
- `PUT /api/v1/categories/:id` - Обновить категорию
- `DELETE /api/v1/categories/:id` - Удалить категорию

#### Funding Sources (Источники финансирования)
- `GET /api/v1/funding-sources` - Список источников финансирования
- `POST /api/v1/funding-sources` - Создать источник финансирования
- `PUT /api/v1/funding-sources/:id` - Обновить источник финансирования
- `DELETE /api/v1/funding-sources/:id` - Удалить источник финансирования

#### Users (Пользователи)
- `GET /api/v1/users` - Список пользователей
- `POST /api/v1/users` - Создать пользователя
- `PUT /api/v1/users/:id` - Обновить пользователя
- `DELETE /api/v1/users/:id` - Удалить пользователя

#### Health Check
- `GET /healthz` - Проверка работоспособности сервиса
- `GET /api/v1/health` - Альтернативный endpoint для health check

### 3.3. Структура базы данных

#### Основные таблицы:

1. **users** - Пользователи системы
   - id (UUID, PK)
   - email (VARCHAR, UNIQUE)
   - password_hash (VARCHAR)
   - full_name (VARCHAR)
   - status (VARCHAR: active/inactive/suspended)

2. **departments** - Отделы (поддерживает иерархию)
   - id (UUID, PK)
   - code (VARCHAR, UNIQUE)
   - name (VARCHAR)
   - parent_id (UUID, FK, nullable)

3. **categories** - Категории расходов (поддерживает иерархию)
   - id (UUID, PK)
   - code (VARCHAR, UNIQUE)
   - name (VARCHAR)
   - parent_id (UUID, FK, nullable)

4. **expenses** - Расходы
   - id (UUID, PK)
   - department_id (UUID, FK)
   - category_id (UUID, FK)
   - amount (DECIMAL(15,2))
   - currency (VARCHAR(3), default: 'USD')
   - incurred_on (DATE)
   - description (TEXT)
   - status (VARCHAR: pending/approved/rejected/paid)
   - funding_source (VARCHAR(50))
   - performer (VARCHAR(255))
   - created_by (UUID, FK)
   - created_at (TIMESTAMPTZ)
   - updated_at (TIMESTAMPTZ)

5. **funding_sources** - Источники финансирования
   - id (UUID, PK)
   - code (VARCHAR, UNIQUE)
   - name (VARCHAR)

6. **roles** - Роли пользователей
   - id (UUID, PK)
   - name (VARCHAR, UNIQUE)

7. **user_roles** - Связь пользователей и ролей
   - user_id (UUID, FK)
   - role_id (UUID, FK)

8. **documents** - Документы/вложения к расходам
   - id (UUID, PK)
   - expense_id (UUID, FK)
   - filename (VARCHAR)
   - storage_key (VARCHAR)
   - size_bytes (BIGINT)

9. **approvals** - Процесс утверждения расходов
   - id (UUID, PK)
   - expense_id (UUID, FK)
   - approver_id (UUID, FK)
   - decision (VARCHAR: approved/rejected)

10. **audit_logs** - Журнал аудита
    - id (UUID, PK)
    - entity (VARCHAR)
    - entity_id (UUID)
    - action (VARCHAR)
    - actor_id (UUID, FK)
    - diff_json (JSONB)

### 3.4. Тестовые данные

Система включает миграцию с тестовыми данными для проверки функциональности аналитики:

**Миграция:** `20251113030000_seed_sample_expenses_for_analytics.sql`

Создает тестовые расходы для трех отделов:
- IT (Информационные технологии)
- FIN (Финансы)
- HR (Кадры)

Примеры категорий расходов:
- Командировки (проживание, транспорт, питание)
- Офисное оборудование и расходные материалы
- Услуги (консультационные, юридические)
- Коммунальные услуги (электричество, интернет)

### 3.5. Особенности реализации

#### Безопасность

1. **CORS настройки:** Backend настраивает CORS для разрешенных источников через переменную окружения `ALLOWED_ORIGINS`

2. **Валидация данных:**
   - Проверка суммы на положительное значение
   - Проверка статуса на допустимые значения
   - Проверка существования связанных сущностей (отдел, категория)

3. **SQL Injection защита:** Использование параметризованных запросов через SQLx

#### Производительность

1. **Индексы БД:** Оптимизированные индексы для частых запросов
2. **Пагинация:** Ограничение количества записей на странице
3. **Connection Pooling:** Использование пула соединений PostgreSQL (максимум 10 соединений)

#### Локализация

Система полностью локализована на русский язык:
- Все интерфейсы на русском
- Справочные данные на русском
- Сообщения об ошибках на русском

### 3.6. Известные ограничения и планы развития

#### Текущие ограничения:

1. **Аутентификация:** В текущей версии используется placeholder для аутентификации. Необходимо реализовать:
   - JWT токены
   - Хеширование паролей с использованием Argon2
   - Middleware для проверки авторизации

2. **Фильтрация:** Не все фильтры реализованы в backend (department_id, category_id, status, date_from, date_to принимаются, но не применяются в запросе)

3. **Загрузка файлов:** Инфраструктура для MinIO создана, но endpoints для загрузки файлов еще не реализованы

#### Планы развития:

- Реализация полноценной аутентификации и авторизации
- Добавление ролевой модели доступа
- Реализация workflow утверждения расходов
- Расширенная аналитика с группировкой по отделам
- Экспорт отчетов в Excel/PDF
- Уведомления по email
- Мобильное приложение

### 3.7. Команды для проверки работоспособности

#### Проверка backend:

```bash
# Health check
curl http://localhost:8080/healthz

# Ожидаемый ответ:
# {"status":"ok","database":"ok"}

# Список расходов
curl http://localhost:8080/api/v1/expenses?page=1&page_size=10

# Список категорий
curl http://localhost:8080/api/v1/categories
```

#### Проверка frontend:

1. Откройте браузер: http://localhost:3000
2. Проверьте навигационное меню
3. Перейдите на страницу "Учёт затрат" - должна отображаться таблица расходов
4. Перейдите на страницу "Аналитика и отчётность" - должны отображаться графики
5. Перейдите на страницу "Управление пользователями" - должна отображаться таблица пользователей

#### Проверка базы данных:

```bash
# Подключение к БД
sudo docker exec -it isit_postgres psql -U isit -d isit

# Проверка таблиц
\dt

# Количество расходов
SELECT COUNT(*) FROM expenses;

# Проверка миграций
SELECT * FROM _sqlx_migrations ORDER BY installed_on DESC;
```

### 3.8. Логирование

Backend использует библиотеку `tracing` для структурированного логирования:

- **Уровень логирования:** Настраивается через переменную окружения `RUST_LOG`
- **Формат:** Компактный формат с временными метками
- **HTTP запросы:** Логируются через `TraceLayer` из tower-http

Пример настройки:
```bash
RUST_LOG=info,tower_http=info cargo run
```

### 3.9. Переменные окружения

#### Backend (.env):

```env
DATABASE_URL=postgres://isit:isit@localhost:5432/isit
SERVER_PORT=8080
ALLOWED_ORIGINS=http://localhost:3000
RUST_LOG=info
S3_ENDPOINT=http://minio:9000
S3_BUCKET=isit-attachments
S3_ACCESS_KEY_ID=admin
S3_SECRET_ACCESS_KEY=adminadmin
```

#### Frontend (.env.local):

```env
NEXT_PUBLIC_API_BASE_URL=http://localhost:8080
```

### 3.10. Репозиторий и версионирование

- **Репозиторий:** https://github.com/kemuri-ni-deteitta/ISIT
- **Ветка по умолчанию:** main
- **Лицензия:** Не указана (собственническое ПО)

### 3.11. Контакты и поддержка

Для вопросов и проблем обращайтесь к разработчикам проекта через GitHub Issues.

---

**Дата составления отчета:** 2025-01-13  
**Версия системы:** 1.0.0

